import numpy as np
import argparse
from sklearn.preprocessing import MinMaxScaler

import torch
import torch.nn as nn
import torch.nn.functional as F
import pickle
import os
import json

np.int = np.int64

class MalConv(nn.Module):
    def __init__(self, input_length=3000000, embedding_dim=8, window_size=5, output_dim=1):
        super(MalConv, self).__init__()
        self.embed = nn.Embedding(input_length, embedding_dim)
        self.conv1 = nn.Conv1d(embedding_dim, 64, kernel_size=window_size, stride=window_size - 3, padding=0)
        self.conv2 = nn.Conv1d(embedding_dim, 64, kernel_size=window_size, stride=window_size - 3, padding=0)
        self.gating = nn.Sigmoid()
        self.global_max_pool = nn.AdaptiveMaxPool1d(1)
        self.fc1 = nn.Linear(64, 64)
        self.fc2 = nn.Linear(64, output_dim)
        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        x = self.embed(x)
        # Convert to (batch_size, channels, length)
        x = x.transpose(1, 2)
        conv1 = self.conv1(x)
        conv2 = self.conv2(x)
        # Element-wise multiplication
        gated = conv1 * self.gating(conv2)
         # Remove the last dimension
        global_max_pool = self.global_max_pool(gated).squeeze(2)
        fc1 = F.relu(self.fc1(global_max_pool))
        fc2 = self.fc2(fc1)
        output = self.sigmoid(fc2)
        return output
    

def model_fn(model_dir):
    print(model_dir)
    model = MalConv()
    with open(os.path.join(model_dir, "Malconv_model_architecture.pth"), "rb") as f:
        model.load_state_dict(torch.load(f))
    model.to('cuda').eval()
    return model


def input_fn(request_body, request_content_type):
    assert request_content_type=='application/json'
    data = json.loads(request_body)['inputs']
    data = torch.tensor(data, dtype=torch.float32, device='cuda')
    return data

def predict_fn(input_object, model):
    with torch.no_grad():
        prediction = model(input_object.to(torch.int64))
    return prediction

def output_fn(prediction, content_type):
    assert content_type == 'application/json'
    res = "Sample"
    if prediction > 0.5:
      res = "It's a Malware"
    else:
      res = "It's a Benign Software"
    return json.dumps(res)